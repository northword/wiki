/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/before-after-hook/lib/register.js
var require_register = __commonJS({
  "node_modules/before-after-hook/lib/register.js"(exports, module2) {
    module2.exports = register;
    function register(state, name, method, options) {
      if (typeof method !== "function") {
        throw new Error("method for before hook must be a function");
      }
      if (!options) {
        options = {};
      }
      if (Array.isArray(name)) {
        return name.reverse().reduce(function(callback, name2) {
          return register.bind(null, state, name2, callback, options);
        }, method)();
      }
      return Promise.resolve().then(function() {
        if (!state.registry[name]) {
          return method(options);
        }
        return state.registry[name].reduce(function(method2, registered) {
          return registered.hook.bind(null, method2, options);
        }, method)();
      });
    }
  }
});

// node_modules/before-after-hook/lib/add.js
var require_add = __commonJS({
  "node_modules/before-after-hook/lib/add.js"(exports, module2) {
    module2.exports = addHook;
    function addHook(state, kind, name, hook2) {
      var orig = hook2;
      if (!state.registry[name]) {
        state.registry[name] = [];
      }
      if (kind === "before") {
        hook2 = function(method, options) {
          return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
        };
      }
      if (kind === "after") {
        hook2 = function(method, options) {
          var result;
          return Promise.resolve().then(method.bind(null, options)).then(function(result_) {
            result = result_;
            return orig(result, options);
          }).then(function() {
            return result;
          });
        };
      }
      if (kind === "error") {
        hook2 = function(method, options) {
          return Promise.resolve().then(method.bind(null, options)).catch(function(error) {
            return orig(error, options);
          });
        };
      }
      state.registry[name].push({
        hook: hook2,
        orig
      });
    }
  }
});

// node_modules/before-after-hook/lib/remove.js
var require_remove = __commonJS({
  "node_modules/before-after-hook/lib/remove.js"(exports, module2) {
    module2.exports = removeHook;
    function removeHook(state, name, method) {
      if (!state.registry[name]) {
        return;
      }
      var index = state.registry[name].map(function(registered) {
        return registered.orig;
      }).indexOf(method);
      if (index === -1) {
        return;
      }
      state.registry[name].splice(index, 1);
    }
  }
});

// node_modules/before-after-hook/index.js
var require_before_after_hook = __commonJS({
  "node_modules/before-after-hook/index.js"(exports, module2) {
    var register = require_register();
    var addHook = require_add();
    var removeHook = require_remove();
    var bind = Function.bind;
    var bindable = bind.bind(bind);
    function bindApi(hook2, state, name) {
      var removeHookRef = bindable(removeHook, null).apply(null, name ? [state, name] : [state]);
      hook2.api = { remove: removeHookRef };
      hook2.remove = removeHookRef;
      ["before", "error", "after", "wrap"].forEach(function(kind) {
        var args = name ? [state, kind, name] : [state, kind];
        hook2[kind] = hook2.api[kind] = bindable(addHook, null).apply(null, args);
      });
    }
    function HookSingular() {
      var singularHookName = "h";
      var singularHookState = {
        registry: {}
      };
      var singularHook = register.bind(null, singularHookState, singularHookName);
      bindApi(singularHook, singularHookState, singularHookName);
      return singularHook;
    }
    function HookCollection() {
      var state = {
        registry: {}
      };
      var hook2 = register.bind(null, state);
      bindApi(hook2, state);
      return hook2;
    }
    var collectionHookDeprecationMessageDisplayed = false;
    function Hook() {
      if (!collectionHookDeprecationMessageDisplayed) {
        console.warn('[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4');
        collectionHookDeprecationMessageDisplayed = true;
      }
      return HookCollection();
    }
    Hook.Singular = HookSingular.bind();
    Hook.Collection = HookCollection.bind();
    module2.exports = Hook;
    module2.exports.Hook = Hook;
    module2.exports.Singular = Hook.Singular;
    module2.exports.Collection = Hook.Collection;
  }
});

// node_modules/node-fetch/browser.js
var require_browser = __commonJS({
  "node_modules/node-fetch/browser.js"(exports, module2) {
    "use strict";
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    };
    var global = getGlobal();
    module2.exports = exports = global.fetch;
    if (global.fetch) {
      exports.default = global.fetch.bind(global);
    }
    exports.Headers = global.Headers;
    exports.Request = global.Request;
    exports.Response = global.Response;
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once2);
    module2.exports.strict = wrappy(onceStrict);
    once2.proto = once2(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once2(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once2(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// mkdocsPublisher/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MkdocsPublication
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// mkdocsPublisher/settings.ts
var import_obsidian2 = require("obsidian");

// mkdocsPublisher/settings/interface.ts
var DEFAULT_SETTINGS = {
  githubRepo: "",
  githubName: "",
  GhToken: "",
  shareKey: "share",
  ExcludedFolder: "",
  fileMenu: false,
  editorMenu: false,
  downloadedFolder: "fixed" /* fixed */,
  folderDefaultName: "",
  yamlFolderKey: "",
  rootFolder: "",
  workflowName: "",
  embedImage: true,
  defaultImageFolder: "",
  autoCleanUp: false,
  autoCleanUpExcluded: "",
  folderNote: false,
  convertWikiLinks: false,
  convertForGithub: false,
  subFolder: "",
  embedNotes: false,
  copyLink: false,
  mainLink: "",
  linkRemover: ""
};

// mkdocsPublisher/settings/stylesSettings.ts
function showSettings(containerEl) {
  containerEl.descEl.show();
  containerEl.nameEl.show();
  containerEl.controlEl.show();
}
function hideSettings(containerEl) {
  containerEl.descEl.hide();
  containerEl.nameEl.hide();
  containerEl.controlEl.hide();
}
function autoCleanCondition(value, autoCleanSetting, plugin) {
  return __async(this, null, function* () {
    const settings = plugin.settings;
    if (value.length === 0 && settings.downloadedFolder) {
      settings.autoCleanUp = false;
      yield plugin.saveSettings();
      autoCleanSetting.setDisabled(true);
      autoCleanSetting.components[0].toggleEl.classList.remove("is-enabled");
    } else if (value.length === 0 && settings.downloadedFolder !== "yaml" /* yaml */) {
      settings.autoCleanUp = false;
      autoCleanSetting.setDisabled(true);
      autoCleanSetting.components[0].toggleEl.classList.remove("is-enabled");
    } else {
      autoCleanSetting.setDisabled(false);
      if (settings.autoCleanUp) {
        autoCleanSetting.components[0].toggleEl.classList.add("is-enabled");
      }
    }
  });
}
function folderHideShowSettings(frontmatterKeySettings, rootFolderSettings, autoCleanSetting, value, plugin, subFolderSettings) {
  return __async(this, null, function* () {
    const settings = plugin.settings;
    if (value === "yaml" /* yaml */) {
      showSettings(frontmatterKeySettings);
      showSettings(rootFolderSettings);
      autoCleanCondition(settings.rootFolder, autoCleanSetting, plugin).then();
      hideSettings(subFolderSettings);
    } else {
      if (settings.folderDefaultName.length > 0) {
        autoCleanSetting.setDisabled(false);
        if (settings.autoCleanUp) {
          autoCleanSetting.components[0].toggleEl.classList.add("is-enabled");
        }
      }
      if (settings.downloadedFolder === "obsidian" /* obsidian */) {
        showSettings(subFolderSettings);
      } else {
        hideSettings(subFolderSettings);
      }
      hideSettings(frontmatterKeySettings);
      hideSettings(rootFolderSettings);
    }
  });
}
function autoCleanUpSettingsOnCondition(condition, autoCleanSetting, plugin) {
  const settings = plugin.settings;
  if (condition) {
    autoCleanSetting.setDisabled(true);
    autoCleanSetting.components[0].toggleEl.classList.remove("is-enabled");
    settings.autoCleanUp = false;
    plugin.saveSettings().then();
  } else {
    autoCleanSetting.setDisabled(false);
    if (settings.autoCleanUp) {
      autoCleanSetting.components[0].toggleEl.classList.add("is-enabled");
    }
  }
}
function shortcutsHideShow(condition, toDisplay) {
  condition ? showSettings(toDisplay) : hideSettings(toDisplay);
}

// mkdocsPublisher/i18n/index.ts
var import_obsidian = require("obsidian");

// mkdocsPublisher/i18n/locales/en-us.ts
var en_us_default = {
  shareActiveFile: "Share active file",
  publisherDeleteClean: "Remove unshared and deleted file in repository",
  uploadAllNotes: "Upload all shared notes",
  uploadNewNotes: "Upload new shared notes",
  uploadAllNewEditedNote: "Upload all new and edited note since last upload",
  uploadAllEditedNote: "Upload all edited note since last upload",
  shareViewFiles: (viewFile) => `Share "${viewFile}" with Mkdocs Publisher`,
  githubConfiguration: "Github Configuration",
  repoName: "Repo Name",
  repoNameDesc: "The name of the repository where you store your blog.",
  mkdocsTemplate: "mkdocs-template",
  githubUsername: "Github Username",
  githubUsernameDesc: "Your github username.",
  ghTokenDesc: "A github token with repository permission. You can generate it ",
  here: "here",
  githubToken: "Github Token",
  uploadConfig: "Upload configuration",
  pathSetting: "Path settings",
  folderBehavior: "Folder behavior",
  folderBehaviorDesc: "Choose between a fixed folder, the value of a frontmatter key or your obsidian relative path.",
  fixedFolder: "Fixed Folder",
  yaml: "YAML frontmatter",
  obsidianPath: "Obsidian Path",
  defaultFolder: "Default Folder",
  defaultFolderDesc: "Set the default reception folder",
  defaultFolderPlaceholder: "docs",
  pathRemoving: "Path removing",
  pathRemovingDesc: "Allow to publish only subfolder by removing the path before that :",
  pathRemovingPlaceholder: "GardenSketch",
  frontmatterKey: "Frontmatter key",
  frontmatterKeyDesc: "Set the key where to get the value of the folder",
  frontmatterKeyPlaceholder: "category",
  rootFolder: "Root folder",
  rootFolderDesc: "Append this path to the folder set by the frontmatter key.",
  linksConversion: "Link's conversion",
  folderNote: "Folder note",
  folderNoteDesc: 'Rename files with the same name as their parent folder (or category) "index.md"',
  internalsLinks: "Internals Links",
  internalsLinksDesc: "Convert the internal link in shared file to match the folder settings",
  wikilinks: "Wikilinks",
  wikilinksDesc: "Convert Wikilinks to MDlinks, without changing the contents",
  embed: "Embed",
  transferImage: "Transfer image",
  transferImageDesc: "Send image embedded in a file to github",
  transferEmbeddedNotes: "Transfer embedded notes",
  transferEmbeddedNotesDesc: "Send embedded notes in a shared file to github. Only shared files will be send!",
  defaultImageFolder: "Default image folder",
  defaultImageFolderDesc: "To use a folder different from default",
  githubActionName: "Github action name",
  githubActionNameDesc: "If you want to activate a github action when the plugin push the file, set the name of the file (in your .github/worfklows folder).",
  autoCleanUp: "Auto clean up",
  autoCleanUpDesc: "If the plugin must remove from github the removed files (stop share or deleted)",
  excludedFiles: "Excluded files",
  excludedFilesDesc: "If you want to exclude some folder from the auto clean up, set their path.",
  pluginSettings: "Plugin Settings",
  shareKey: "Share Key",
  shareKeyDesc: "The frontmatter key to publish your file on the website.",
  excludedFolder: "Excluded Folder",
  excludedFolderDesc: "Never publish file in these folder, regardless of the share key. Separate folder name by comma.",
  fileMenu: "File Menu",
  fileMenuDesc: "Add an sharing commands in the file menu",
  editorMenu: "Editor Menu",
  editorMenuDesc: "Add a sharing commands in the right-click menu",
  copylinkSetting: "Copy link setting",
  copylinkDesc: "Send a link to your note in your clipboard",
  baselink: "Blog link",
  baselinkDesc: "Create the clipboard link with this base. By default : https://username.github.io/repo/",
  linkpathremover: "Remove link part",
  linkpathremoverDesc: "Remove this part from the created links. Separate by comma if multiple value must be removed.",
  unablePublishNote: (fileInfo) => `Unable to publish note ${fileInfo}\uFF0Cskipping it`,
  errorPublish: (repoInfo) => `Error publishing to ${repoInfo}.`,
  unablePublishMultiNotes: "Unable to publish multiple notes, something went wrong.",
  startingClean: (repoInfo) => `Starting cleaning ${repoInfo}`,
  scanningRepo: "Scanning the repository, may take a while...",
  foundNoteToSend: (noteLength) => `Found ${noteLength} new notes to send`,
  noNewNote: "No new notes to share.",
  successfullPublish: (noticeValue) => `Successfully published ${noticeValue[0]} to ${noticeValue[1]}.`,
  waitingWorkflow: "Now, waiting for the workflow to be completed...",
  sendMessage: (noticeValue) => `Send ${noticeValue[0]} to ${noticeValue[1]}${noticeValue[2]}`
};

// mkdocsPublisher/i18n/locales/zh-cn.ts
var zh_cn_default = {
  shareActiveFile: "\u4E0A\u4F20\u5F53\u524D\u6587\u4EF6",
  publisherDeleteClean: "\u4E91\u7AEF\u79FB\u9664\u672C\u5730\u672A\u5206\u4EAB\u548C\u5DF2\u5220\u9664\u7684\u6587\u4EF6",
  uploadAllNotes: "\u4E0A\u4F20\u6240\u6709\u5206\u4EAB\u7684\u6587\u4EF6",
  uploadNewNotes: "\u4E0A\u4F20\u65B0\u5206\u4EAB\u7684\u6587\u4EF6",
  uploadAllNewEditedNote: "\u4E0A\u4F20\u65B0\u5EFA\u7ACB\u6587\u4EF6\u7684\u548C\u66F4\u65B0\u5DF2\u7F16\u8F91\u7684\u5206\u4EAB\u6587\u4EF6",
  uploadAllEditedNote: "\u66F4\u65B0\u6240\u6709\u5DF2\u7F16\u8F91\u7684\u6587\u4EF6",
  shareViewFiles: (viewFile) => `\u7528Mkdocs Publisher\u5171\u4EAB"${viewFile}"\u3002`,
  githubConfiguration: "Github\u8BBE\u7F6E",
  repoName: "\u4ED3\u5E93\u540D",
  repoNameDesc: "\u4F60\u535A\u5BA2\u6240\u5728\u7684github\u4ED3\u5E93\u540D",
  mkdocsTemplate: "mkdocs\u6A21\u677F",
  githubUsername: "Github\u7528\u6237\u540D",
  githubUsernameDesc: "\u4F60github\u7684\u7528\u6237\u540D",
  ghTokenDesc: "github\u4ED3\u5E93\u7684\u64CD\u4F5C\u9700\u8981github token\u7ED9\u4E88\u6743\u9650\uFF0C\u4F60\u53EF\u4EE5\u5728",
  here: "\u8FD9\u91CC\u751F\u6210",
  githubToken: "Github Token",
  uploadConfig: "\u4E0A\u4F20\u8BBE\u7F6E",
  pathSetting: "\u8DEF\u5F84\u8BBE\u7F6E",
  folderBehavior: "\u6587\u4EF6\u5939\u64CD\u4F5C",
  folderBehaviorDesc: "\u9009\u62E9\u4F9D\u636E\u56FA\u5B9A\u6587\u4EF6\u5939\uFF0Cfrontmatter key\u8FD8\u662Fob\u7684\u76F8\u5BF9\u8DEF\u5F84\u4E0A\u4F20\u6587\u4EF6",
  fixedFolder: "\u56FA\u5B9A\u6587\u4EF6\u5939",
  yaml: "YAML frontmatter",
  obsidianPath: "Obsidian\u76F8\u5BF9\u8DEF\u5F84",
  defaultFolder: "\u9ED8\u8BA4github\u63A5\u6536\u7684\u6587\u4EF6\u5939",
  defaultFolderDesc: "\u9ED8\u8BA4github\u9ED8\u8BA4\u63A5\u6536\u7684\u6587\u4EF6\u5939",
  defaultFolderPlaceholder: "docs",
  pathRemoving: "\u79FB\u9664\u8DEF\u5F84",
  pathRemovingDesc: "\u5141\u8BB8\u901A\u8FC7\u5220\u9664\u4E4B\u524D\u7684\u8DEF\u5F84\u4EC5\u53D1\u5E03\u5B50\u6587\u4EF6\u5939:",
  pathRemovingPlaceholder: "GardenSketch",
  frontmatterKey: "Frontmatter key",
  frontmatterKeyDesc: "\u8BBE\u7F6E\u4E91\u7AEF\u7528\u4E8E\u5EFA\u7ACB\u6587\u4EF6\u5939\u540D\u7684\u952E\uFF0C\u9ED8\u8BA4\u4E3Acategory",
  frontmatterKeyPlaceholder: "category",
  rootFolder: "\u6839\u6587\u4EF6\u5939",
  rootFolderDesc: "\u5C06\u6B64\u8DEF\u5F84\u8FFD\u52A0\u5230\u6587\u4EF6\u5939\u524D",
  linksConversion: "\u94FE\u63A5\u8F6C\u6362",
  folderNote: "Folder note",
  folderNoteDesc: '\u91CD\u547D\u540D\u6587\u4EF6\u4E3A\u5176\u7236\u6587\u4EF6\u5939\u540D(\u6216category\u540D) "index.md"',
  internalsLinks: "\u5185\u90E8\u94FE\u63A5",
  internalsLinksDesc: "\u8F6C\u6362\u53D1\u5E03\u6587\u4EF6\u4E2D\u7684\u5185\u90E8\u94FE\u63A5",
  wikilinks: "Wikilinks",
  wikilinksDesc: "\u8F6C\u6362wiki link\u4E3Amd link\uFF0C\u4E0D\u6539\u53D8\u6587\u4EF6\u5185\u5BB9",
  embed: "\u5D4C\u5165",
  transferImage: "\u8F6C\u6362\u56FE\u7247",
  transferImageDesc: "\u53D1\u9001\u6587\u4EF6\u4E2D\u63D2\u5165\u7684\u56FE\u7247\u81F3github",
  transferEmbeddedNotes: "\u8F6C\u6362\u5D4C\u5165\u7684\u7B14\u8BB0",
  transferEmbeddedNotesDesc: "\u53D1\u5E03\u6587\u4EF6\u4E2D\u5D4C\u5165\u7684\u6587\u4EF6\u81F3github.\u8BE5\u5D4C\u5165\u6587\u4EF6\u9700\u8981\u5141\u8BB8\u88AB\u53D1\u5E03",
  defaultImageFolder: "\u9ED8\u8BA4\u56FE\u7247\u6587\u4EF6\u5939",
  defaultImageFolderDesc: "\u4F7F\u7528\u4E0E\u9ED8\u8BA4\u6587\u6863\u5939\u4E0D\u540C\u7684\u6587\u6863\u5939",
  githubActionName: "Github action\u540D",
  githubActionNameDesc: "\u5982\u679C\u8981\u5728\u63D2\u4EF6\u63A8\u9001\u6587\u6863\u65F6\u6FC0\u6D3B github action\uFF0C\u8BF7\u8BBE\u7F6E\u5BF9\u5E94\u7684action\u540D\u79F0\uFF08\u5728 .github/worfklows \u6587\u6863\u5939\u4E2D\uFF09\u3002",
  autoCleanUp: "\u81EA\u52A8\u6E05\u7406",
  autoCleanUpDesc: "\u5982\u679C\u63D2\u4EF6\u5FC5\u987B\u4ECEgithub\u4E2D\u5220\u9664\u672C\u5730\u5DF2\u5220\u9664\u7684\u6587\u6863\uFF08\u505C\u6B62\u5171\u4EAB\u6216\u5220\u9664\uFF09",
  excludedFiles: "\u6392\u9664\u6587\u4EF6",
  excludedFilesDesc: "\u5982\u679C\u8981\u4ECE\u81EA\u52A8\u6E05\u7406\u4E2D\u6392\u9664\u67D0\u4E9B\u6587\u6863\u5939\uFF0C\u8BF7\u8BBE\u7F6E\u5176\u8DEF\u5F84\u3002",
  pluginSettings: "\u63D2\u4EF6\u8BBE\u7F6E",
  shareKey: "\u5206\u4EAB\u952E",
  shareKeyDesc: "\u5728\u7F51\u7AD9\u4E0A\u53D1\u5E03\u6587\u6863\u7684frontmatter\u7684\u952E",
  excludedFolder: "\u6392\u9664\u6587\u4EF6\u5939",
  excludedFolderDesc: "\u6392\u9664\u8BE5\u6587\u6863\u5939\u4E2D\u6240\u6709\u6587\u6863\uFF0C\u65E0\u8BBA\u662F\u5426\u6709\u5206\u4EAB\u952E\u7684frontmatter\u3002\u591A\u4E2A\u6587\u4EF6\u5939\u7528\u9017\u53F7\u5206\u9694\u3002",
  fileMenu: "\u6587\u4EF6\u83DC\u5355",
  fileMenuDesc: "\u5728\u6587\u4EF6\u6811\u6DFB\u52A0\u53F3\u952E\u5206\u4EAB\u547D\u4EE4",
  editorMenu: "\u7F16\u8F91\u5668\u83DC\u5355",
  editorMenuDesc: "\u5728\u53F3\u952E\u6DFB\u52A0\u5206\u4EAB\u547D\u4EE4",
  copylinkSetting: "\u590D\u5236\u94FE\u63A5\u8BBE\u7F6E",
  copylinkDesc: "\u5728\u4F60\u7684\u526A\u8D34\u677F\u4E2D\u53D1\u9001\u4E00\u4E2A\u94FE\u63A5\u5230\u4F60\u7684\u7B14\u8BB0\u4E0A",
  baselink: "\u535A\u5BA2\u94FE\u63A5",
  baselinkDesc: "\u4EE5\u6B64\u4E3A\u57FA\u7840\u521B\u5EFA\u526A\u8D34\u677F\u94FE\u63A5\u3002\u9ED8\u8BA4\u60C5\u51B5\u4E0B : https://username.github.io/repo/",
  linkpathremover: "\u5220\u9664\u94FE\u63A5\u90E8\u5206",
  linkpathremoverDesc: "\u4ECE\u521B\u5EFA\u7684\u94FE\u63A5\u4E2D\u5220\u9664\u8FD9\u90E8\u5206\u3002\u5982\u679C\u5FC5\u987B\u5220\u9664\u591A\u4E2A\u503C\uFF0C\u8BF7\u7528\u9017\u53F7\u5206\u5F00\u3002",
  unablePublishNote: (fileInfo) => {
    return `\u4E0D\u80FD\u4E0A\u4F20\u6587\u4EF6${fileInfo}\uFF0C\u5DF2\u8DF3\u8FC7`;
  },
  errorPublish: (repoInfo) => `\u4E0A\u4F20\u81F3${repoInfo}\u9519\u8BEF\uFF01`,
  unablePublishMultiNotes: "\u4E0D\u80FD\u4E0A\u4F20\u591A\u4E2A\u6587\u4EF6\uFF0C\u51FA\u4E86\u70B9\u95EE\u9898",
  startingClean: (repoInfo) => `\u5F00\u59CB\u6E05\u7406 ${repoInfo}`,
  scanningRepo: "\u626B\u63CF\u4ED3\u5E93\u4E2D\uFF0C\u7A0D\u7B49...",
  foundNoteToSend: (noteLength) => `\u53D1\u73B0 ${noteLength} \u7BC7\u7B14\u8BB0\u9700\u8981\u4E0A\u4F20`,
  noNewNote: "\u6CA1\u6709\u65B0\u7B14\u8BB0\u9700\u8981\u4E0A\u4F20.",
  successfullPublish: (noticeValue) => `\u6210\u529F\u5730\u5C06${noticeValue[0]}\u53D1\u5E03\u5230${noticeValue[1]}\u3002`,
  waitingWorkflow: "\u73B0\u5728\uFF0C\u7B49\u5F85\u5DE5\u4F5C\u6D41\u7A0B\u7684\u5B8C\u6210...",
  sendMessage: (noticeValue) => `\u5C06${noticeValue[0]}\u53D1\u9001\u5230${noticeValue[1]}${noticeValue[2]}\u3002`
};

// mkdocsPublisher/i18n/locales/fr-fr.ts
var fr_fr_default = {
  shareActiveFile: "Partager le fichier actif",
  publisherDeleteClean: "Suppression des fichiers non partag\xE9s et/ou supprim\xE9 du d\xE9p\xF4t ",
  uploadAllNotes: "Publier toutes les notes partag\xE9es",
  uploadNewNotes: "Publier les nouvelles notes",
  uploadAllNewEditedNote: "Publier toutes les notes nouvelles et modifi\xE9es depuis le dernier envoi.",
  uploadAllEditedNote: "Publier toutes les notes \xE9dit\xE9es depuis le dernier envoie",
  shareViewFiles: (viewFile) => `Partager "${viewFile}" avec Mkdocs Publisher`,
  githubConfiguration: "Configuration GitHub",
  repoName: "Nom du d\xE9p\xF4t",
  repoNameDesc: "Le nom du d\xE9p\xF4t dans lequel vous enregistrez votre blog",
  mkdocsTemplate: "mkdocs-template",
  githubUsername: "Nom d'utilisateur GitHub",
  githubUsernameDesc: "Votre nom d'utilisateur GitHub",
  ghTokenDesc: "Un token GitHub avec autorisation de d\xE9p\xF4t. Vous pouvez le g\xE9n\xE9rer ",
  here: "ici",
  githubToken: "Token GitHub",
  uploadConfig: "Configuration d'envoie",
  pathSetting: "Param\xE8tres du chemin d'acc\xE8s",
  folderBehavior: "Comportement du dossier",
  folderBehaviorDesc: "Choisissez entre un dossier fixe, la valeur d'une cl\xE9 de m\xE9tadonn\xE9e ou votre chemin relatif dans Obsidian.",
  fixedFolder: "Dossier fix\xE9",
  yaml: "Cl\xE9 de m\xE9tadonn\xE9e",
  obsidianPath: "Chemin Obsidian",
  defaultFolder: "Dossier par d\xE9faut",
  defaultFolderDesc: "D\xE9finir le dossier de r\xE9ception par d\xE9faut",
  defaultFolderPlaceholder: "docs",
  pathRemoving: "Suppression de chemin",
  pathRemovingDesc: "Permettre de publier uniquement le sous-dossier en supprimant le chemin avant celui-ci :",
  pathRemovingPlaceholder: "Blog",
  frontmatterKey: "Cl\xE9 de m\xE9tadonn\xE9es",
  frontmatterKeyDesc: "D\xE9finir la cl\xE9 o\xF9 obtenir la valeur du dossier",
  frontmatterKeyPlaceholder: "cat\xE9gorie",
  rootFolder: "Dossier racine",
  rootFolderDesc: "Ajoutez ce chemin au dossier d\xE9fini par la cl\xE9 de m\xE9tadonn\xE9es.",
  linksConversion: "Conversion des liens",
  folderNote: "Note de dossier",
  folderNoteDesc: 'Renommer les fichiers portant le m\xEAme nom que leur dossier (ou cat\xE9gorie) parent "index.md".',
  internalsLinks: "Liens internes",
  internalsLinksDesc: "Convertir le lien interne dans le fichier partag\xE9 pour qu'il corresponde aux param\xE8tres du dossier",
  wikilinks: "Wikilinks",
  wikilinksDesc: "Convertir les liens Wikilinks en liens markdown, sans en modifier le contenu",
  embed: "Transclusion",
  transferImage: "Transf\xE9rer les images",
  transferImageDesc: "Envoyer les images int\xE9gr\xE9es dans un fichier dans le d\xE9p\xF4t.",
  transferEmbeddedNotes: "Transf\xE9rer les notes transcluent.",
  transferEmbeddedNotesDesc: "Envoyez des notes transcluent dans un fichier partag\xE9 dans le d\xE9p\xF4t. Seuls les fichiers partag\xE9s seront envoy\xE9s !",
  defaultImageFolder: "Dossier d'images par d\xE9faut",
  defaultImageFolderDesc: "Pour utiliser un dossier diff\xE9rent de celui par d\xE9faut pour les images",
  githubActionName: "Nom de l'action GitHub",
  githubActionNameDesc: "Si vous souhaitez activer une action github lorsque le plugin pousse le fichier, indiquez le nom du fichier (dans votre dossier .github/worfklows).",
  autoCleanUp: "Auto-nettoyage",
  autoCleanUpDesc: "Si le plugin doit retirer de votre d\xE9p\xF4t les fichiers supprim\xE9s (arr\xEAt de partage ou supprim\xE9)",
  excludedFiles: "Fichier exclus",
  excludedFilesDesc: "Si vous voulez exclure certains dossiers du nettoyage automatique, d\xE9finissez leur chemin.",
  pluginSettings: "Param\xE8tres du plugin",
  shareKey: "Cl\xE9 de partage",
  shareKeyDesc: "La cl\xE9 de m\xE9tadonn\xE9es pour publier votre fichier sur le d\xE9p\xF4t.",
  excludedFolder: "Dossier exclus",
  excludedFolderDesc: "Les fichiers dans ses dossiers ne seront jamais publier, quelle que soit l'\xE9tat de la cl\xE9 de partage. S\xE9parez les noms de dossier par une virgule.",
  fileMenu: 'Menu "Fichier"',
  fileMenuDesc: 'Ajouter une commande de partage dans le menu "Fichier"',
  editorMenu: 'Menu "Edition"',
  editorMenuDesc: "Ajouter une commande de partage dans le menu du clic droit",
  copylinkSetting: "Param\xE8tre de copie",
  copylinkDesc: "Envoyer un lien vers votre note dans votre presse-papier.",
  baselink: "Lien du blog",
  baselinkDesc: "Cr\xE9er le lien du presse-papiers avec cette base. Par d\xE9faut : https://username.github.io/repo/",
  linkpathremover: "Retirer une partie du lien",
  linkpathremoverDesc: "Supprimer cette partie des liens cr\xE9\xE9s. S\xE9parer par une virgule si plusieurs valeurs doivent \xEAtre supprim\xE9es.",
  unablePublishNote: (fileInfo) => `Impossible de publier la note ${fileInfo}, ignor\xE9e.`,
  errorPublish: (repoInfo) => `Erreur lors de la publication sur ${repoInfo}.`,
  unablePublishMultiNotes: "Impossible de publier plusieurs notes, quelque chose s'est mal pass\xE9.",
  startingClean: (repoInfo) => `D\xE9but du nettoyage ${repoInfo}`,
  scanningRepo: "Scan du d\xE9p\xF4t, cela peut prendre un moment...",
  foundNoteToSend: (noteLength) => `Trouv\xE9 ${noteLength} nouvelles notes \xE0 envoyer`,
  noNewNote: "Aucune nouvelle note \xE0 partager.",
  successfullPublish: (noticeValue) => `Publication r\xE9ussie de ${noticeValue[0]} vers ${noticeValue[1]}.`,
  waitingWorkflow: "Maintenant, attente de la compl\xE9tion du workflow...",
  sendMessage: (noticeValue) => `Envoi de ${noticeValue[0]} \xE0 ${noticeValue[1]}${noticeValue[2]}`
};

// mkdocsPublisher/i18n/index.ts
var localeMap = {
  enUS: en_us_default,
  "zh-cn": zh_cn_default,
  "fr": fr_fr_default
};
var locale = localeMap[import_obsidian.moment.locale()];
function t(str) {
  return locale && locale[str] || en_us_default[str];
}

// mkdocsPublisher/settings.ts
var MkdocsSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: t("githubConfiguration") });
    new import_obsidian2.Setting(containerEl).setName(t("repoName")).setDesc(t("repoNameDesc")).addText((text) => text.setPlaceholder("mkdocs-template").setValue(this.plugin.settings.githubRepo).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.githubRepo = value.trim();
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(containerEl).setName(t("githubUsername")).setDesc(t("githubUsernameDesc")).addText((text) => text.setPlaceholder(t("githubUsername")).setValue(this.plugin.settings.githubName).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.githubName = value.trim();
      yield this.plugin.saveSettings();
    })));
    const desc_ghToken = document.createDocumentFragment();
    desc_ghToken.createEl("span", null, (span) => {
      span.innerText = t("ghTokenDesc");
      span.createEl("a", null, (link) => {
        link.innerText = t("here");
        link.href = "https://github.com/settings/tokens/new?scopes=repo,workflow";
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("githubToken")).setDesc(desc_ghToken).addText((text) => text.setPlaceholder("ghb-15457498545647987987112184").setValue(this.plugin.settings.GhToken).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.GhToken = value.trim();
      yield this.plugin.saveSettings();
    })));
    containerEl.createEl("h2", { text: t("uploadConfig") });
    containerEl.createEl("h3", { text: t("pathSetting") });
    new import_obsidian2.Setting(this.containerEl).setName(t("folderBehavior")).setDesc(t("folderBehaviorDesc")).addDropdown((dropDown) => {
      dropDown.addOptions({
        fixed: t("fixedFolder"),
        yaml: t("yaml"),
        obsidian: t("obsidianPath")
      }).setValue(this.plugin.settings.downloadedFolder).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.downloadedFolder = value;
        yield folderHideShowSettings(frontmatterKeySettings, rootFolderSettings, autoCleanSetting, value, this.plugin, subFolderSettings);
        if (value === "fixed" /* fixed */) {
          hideSettings(folderNoteSettings);
        } else {
          showSettings(folderNoteSettings);
          if (value === "obsidian" /* obsidian */) {
            showSettings(subFolderSettings);
          }
        }
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian2.Setting(this.containerEl).setName(t("defaultFolder")).setDesc(t("defaultFolderDesc")).addText((text) => {
      text.setPlaceholder("docs").setValue(this.plugin.settings.folderDefaultName).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.folderDefaultName = value.replace(/\/$/, "");
        yield autoCleanCondition(value, autoCleanSetting, this.plugin);
        yield this.plugin.saveSettings();
      }));
    });
    const subFolderSettings = new import_obsidian2.Setting(this.containerEl).setName(t("pathRemoving")).setClass("mdkocs-settings-tab").setDesc(t("pathRemovingDesc")).addText((text) => {
      text.setPlaceholder(t("pathRemovingPlaceholder")).setValue(this.plugin.settings.subFolder).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.subFolder = value.replace(/\/$/, "").trim();
        yield this.plugin.saveSettings();
      }));
    });
    const frontmatterKeySettings = new import_obsidian2.Setting(this.containerEl).setName(t("frontmatterKey")).setClass("mdkocs-settings-tab").setDesc(t("frontmatterKeyDesc")).addText((text) => {
      text.setPlaceholder("category").setValue(this.plugin.settings.yamlFolderKey).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.yamlFolderKey = value.trim();
        yield this.plugin.saveSettings();
      }));
    });
    const rootFolderSettings = new import_obsidian2.Setting(this.containerEl).setName(t("rootFolder")).setClass("mdkocs-settings-tab").setDesc(t("rootFolderDesc")).addText((text) => {
      text.setPlaceholder("docs").setValue(this.plugin.settings.rootFolder).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.rootFolder = value.replace(/\/$/, "");
        yield autoCleanCondition(value, autoCleanSetting, this.plugin);
        yield this.plugin.saveSettings();
      }));
    });
    containerEl.createEl("h3", { text: t("linksConversion") });
    const folderNoteSettings = new import_obsidian2.Setting(containerEl).setName(t("folderNote")).setClass("mdkocs-settings-tab").setDesc(t("folderNoteDesc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.folderNote).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.folderNote = value;
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian2.Setting(containerEl).setName(t("internalsLinks")).setDesc(t("internalsLinksDesc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.convertForGithub).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.convertForGithub = value;
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian2.Setting(containerEl).setName(t("wikilinks")).setDesc(t("wikilinksDesc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.convertWikiLinks).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.convertWikiLinks = value;
        yield this.plugin.saveSettings();
      }));
    });
    containerEl.createEl("h3", { text: t("embed") });
    new import_obsidian2.Setting(containerEl).setName(t("transferImage")).setDesc(t("transferImageDesc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.embedImage).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.embedImage = value;
        shortcutsHideShow(value, settingsDefaultImage);
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian2.Setting(containerEl).setName(t("transferEmbeddedNotes")).setDesc(t("transferEmbeddedNotesDesc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.embedNotes).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.embedNotes = value;
        yield this.plugin.saveSettings();
      }));
    });
    const settingsDefaultImage = new import_obsidian2.Setting(containerEl).setName(t("defaultImageFolder")).setDesc(t("defaultImageFolderDesc")).addText((text) => {
      text.setPlaceholder("docs/images").setValue(this.plugin.settings.defaultImageFolder).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.defaultImageFolder = value.replace(/\/$/, "");
        yield this.plugin.saveSettings();
      }));
    });
    containerEl.createEl("h3", { text: "Github Workflow" });
    new import_obsidian2.Setting(containerEl).setName(t("githubActionName")).setDesc(t("githubActionNameDesc")).addText((text) => {
      text.setPlaceholder("ci").setValue(this.plugin.settings.workflowName).onChange((value) => __async(this, null, function* () {
        value = value.length > 0 ? value.trim().replace(".yml", "") + ".yml" : value;
        this.plugin.settings.workflowName = value;
        yield this.plugin.saveSettings();
      }));
    });
    const condition = this.plugin.settings.downloadedFolder === "yaml" /* yaml */ && this.plugin.settings.rootFolder.length === 0 || this.plugin.settings.folderDefaultName.length === 0;
    const autoCleanSetting = new import_obsidian2.Setting(containerEl).setName(t("autoCleanUp")).setDesc(t("autoCleanUpDesc")).setDisabled(condition).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.autoCleanUp).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.autoCleanUp = value;
        shortcutsHideShow(value, autoCleanExcludedSettings);
        yield this.plugin.saveSettings();
      }));
    });
    const autoCleanExcludedSettings = new import_obsidian2.Setting(containerEl).setName(t("excludedFiles")).setDesc(t("excludedFilesDesc")).addTextArea((textArea) => {
      textArea.setPlaceholder("docs/assets/js, docs/assets/logo").setValue(this.plugin.settings.autoCleanUpExcluded).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.autoCleanUpExcluded = value;
        yield this.plugin.saveSettings();
      }));
    });
    containerEl.createEl("h1", { text: t("pluginSettings") });
    new import_obsidian2.Setting(containerEl).setName(t("shareKey")).setDesc(t("shareKeyDesc")).addText((text) => text.setPlaceholder("share").setValue(this.plugin.settings.shareKey).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.shareKey = value.trim();
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(containerEl).setName(t("excludedFolder")).setDesc(t("excludedFolderDesc")).addTextArea((textArea) => textArea.setPlaceholder("_assets, Archive").setValue(this.plugin.settings.ExcludedFolder).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.ExcludedFolder = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(containerEl).setName(t("fileMenu")).setDesc(t("fileMenuDesc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.fileMenu).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.fileMenu = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(containerEl).setName(t("editorMenu")).setDesc(t("editorMenuDesc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.editorMenu).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.editorMenu = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(containerEl).setName(t("copylinkSetting")).setDesc(t("copylinkDesc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.copyLink).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.copyLink = value;
      shortcutsHideShow(value, baseLinkSettings);
      shortcutsHideShow(value, pathRemover);
      yield this.plugin.saveSettings();
    })));
    const baseLinkSettings = new import_obsidian2.Setting(containerEl).setName(t("baselink")).setDesc(t("baselinkDesc")).setClass("mdkocs-settings-tab").addText((text) => {
      text.setPlaceholder("my_blog.com").setValue(this.plugin.settings.mainLink).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.mainLink = value;
        yield this.plugin.saveSettings();
      }));
    });
    const pathRemover = new import_obsidian2.Setting(containerEl).setName(t("linkpathremover")).setDesc(t("linkpathremoverDesc")).setClass("mdkocs-settings-tab").addText((text) => {
      text.setPlaceholder("docs/").setValue(this.plugin.settings.linkRemover).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.linkRemover = value;
        yield this.plugin.saveSettings();
      }));
    });
    autoCleanUpSettingsOnCondition(condition, autoCleanSetting, this.plugin);
    this.plugin.settings.downloadedFolder === "fixed" /* fixed */ ? hideSettings(folderNoteSettings) : showSettings(folderNoteSettings);
    folderHideShowSettings(frontmatterKeySettings, rootFolderSettings, autoCleanSetting, this.plugin.settings.downloadedFolder, this.plugin, subFolderSettings).then();
    shortcutsHideShow(this.plugin.settings.embedImage, settingsDefaultImage);
    shortcutsHideShow(this.plugin.settings.autoCleanUp, autoCleanExcludedSettings);
    shortcutsHideShow(this.plugin.settings.copyLink, baseLinkSettings);
    shortcutsHideShow(this.plugin.settings.copyLink, pathRemover);
  }
};

// mkdocsPublisher/utils/utils.ts
var import_obsidian3 = require("obsidian");

// mkdocsPublisher/utils/filePathConvertor.ts
function createRelativePath(sourceFile, targetFile, metadata, settings) {
  const sourcePath = getReceiptFolder(sourceFile, settings, metadata);
  const frontmatter = metadata.getCache(targetFile.linked.path) ? metadata.getCache(targetFile.linked.path).frontmatter : null;
  if (targetFile.linked.extension === "md" && (!frontmatter || !frontmatter[settings.shareKey] || frontmatter[settings.shareKey] === false)) {
    return targetFile.altText;
  }
  const targetPath = targetFile.linked.extension === "md" ? getReceiptFolder(targetFile.linked, settings, metadata) : getImageLinkOptions(targetFile.linked, settings);
  const sourceList = sourcePath.split("/");
  const targetList = targetPath.split("/");
  const diffSourcePath = sourceList.filter((x) => !targetList.includes(x));
  const diffTargetPath = targetList.filter((x) => !sourceList.includes(x));
  const diffTarget = function(folderPath) {
    const relativePath = [];
    for (const folder of folderPath) {
      if (folder != folderPath.at(-1)) {
        relativePath.push("..");
      }
    }
    return relativePath;
  };
  return diffTarget(diffSourcePath).concat(diffTargetPath).join("/");
}
function createObsidianPath(file, settings) {
  const folderDefault = settings.folderDefaultName;
  const fileName = file.name.replace(".md", "") === file.parent.name && settings.folderNote ? "index.md" : file.name;
  const rootFolder = folderDefault.length > 0 ? folderDefault + "/" : "";
  const path = rootFolder + file.path.replace(file.name, fileName);
  if (settings.subFolder.length > 0) {
    return path.replace(settings.subFolder + "/", "");
  }
  return path;
}
function createFrontmatterPath(file, settings, metadataCache) {
  let path = settings.folderDefaultName.length > 0 ? settings.folderDefaultName + "/" + file.name : file.name;
  const frontmatter = metadataCache.getCache(file.path).frontmatter;
  let folderRoot = settings.rootFolder;
  if (frontmatter && !frontmatter[settings.shareKey]) {
    return file.name;
  }
  if (folderRoot.length > 0) {
    folderRoot = folderRoot + "/";
  }
  if (frontmatter && frontmatter[settings.yamlFolderKey]) {
    const category = frontmatter[settings.yamlFolderKey];
    const parentCatFolder = !category.endsWith("/") ? category.split("/").at(-1) : category.split("/").at(-2);
    const fileName = settings.folderNote && parentCatFolder === file.name.replace(".md", "") ? "index.md" : file.name;
    path = folderRoot + frontmatter[settings.yamlFolderKey] + "/" + fileName;
  }
  return path;
}
function getReceiptFolder(file, settings, metadataCache) {
  if (file.extension === "md") {
    let path = settings.folderDefaultName.length > 0 ? settings.folderDefaultName + "/" + file.name : file.name;
    if (settings.downloadedFolder === "yaml" /* yaml */) {
      path = createFrontmatterPath(file, settings, metadataCache);
    } else if (settings.downloadedFolder === "obsidian" /* obsidian */) {
      path = createObsidianPath(file, settings);
    }
    return path;
  }
}
function getImageLinkOptions(file, settings) {
  let fileDefaultPath = file.path;
  const fileName = file.name;
  if (settings.defaultImageFolder.length > 0) {
    fileDefaultPath = settings.defaultImageFolder + "/" + fileName;
  } else if (settings.folderDefaultName.length > 0) {
    fileDefaultPath = settings.folderDefaultName + "/" + fileName;
  }
  return fileDefaultPath;
}

// mkdocsPublisher/utils/utils.ts
function disablePublish(app2, settings, file) {
  const fileCache = app2.metadataCache.getFileCache(file);
  const meta = fileCache == null ? void 0 : fileCache.frontmatter;
  const folderList = settings.ExcludedFolder.split(",").filter((x) => x !== "");
  if (meta === void 0) {
    return false;
  } else if (folderList.length > 0) {
    for (let i = 0; i < folderList.length; i++) {
      if (file.path.contains(folderList[i].trim())) {
        return false;
      }
    }
  }
  return meta[settings.shareKey];
}
function checkSlash(link) {
  const slash = link.match(/\/*$/);
  if (slash[0].length != 1) {
    link = link.replace(/\/*$/, "") + "/";
  }
  return link;
}
function createLink(file, settings, metadataCache) {
  return __async(this, null, function* () {
    if (!settings.copyLink) {
      return;
    }
    let filepath = getReceiptFolder(file, settings, metadataCache);
    let baseLink = settings.mainLink;
    if (baseLink.length === 0) {
      baseLink = `https://${settings.githubName}.github.io/${settings.githubRepo}/`;
    }
    baseLink = checkSlash(baseLink);
    if (settings.linkRemover.length > 0) {
      const tobeRemoved = settings.linkRemover.split(",");
      for (const part of tobeRemoved) {
        if (part.length > 0) {
          filepath = filepath.replace(part.trim(), "");
        }
      }
    }
    const url = encodeURI(baseLink + filepath.replace(".md", ""));
    yield navigator.clipboard.writeText(url);
    return;
  });
}
function noticeMessage(PublisherManager, file, settings) {
  return __async(this, null, function* () {
    const noticeValue = file instanceof import_obsidian3.TFile ? '"' + file.basename + '"' : file;
    if (settings.workflowName.length > 0) {
      new import_obsidian3.Notice(t("sendMessage")([noticeValue, settings.githubRepo, `.
${t("waitingWorkflow")}`]));
      const successWorkflow = yield PublisherManager.workflowGestion();
      if (successWorkflow) {
        new import_obsidian3.Notice(t("successfullPublish")([noticeValue, settings.githubRepo]));
      }
    } else {
      new import_obsidian3.Notice(t("successfullPublish")([noticeValue, settings.githubRepo]));
    }
  });
}
function trimObject(obj) {
  const trimmed = JSON.stringify(obj, (key, value) => {
    if (typeof value === "string") {
      return value.trim().toLowerCase();
    }
    return value;
  });
  return JSON.parse(trimmed);
}

// node_modules/universal-user-agent/dist-web/index.js
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && "version" in process) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/core/dist-web/index.js
var import_before_after_hook = __toESM(require_before_after_hook());

// node_modules/is-plain-object/dist/is-plain-object.mjs
function isObject(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function isPlainObject(o) {
  var ctor, prot;
  if (isObject(o) === false)
    return false;
  ctor = o.constructor;
  if (ctor === void 0)
    return true;
  prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}

// node_modules/@octokit/endpoint/dist-web/index.js
function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
}
function merge(defaults, route, options) {
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (defaults && defaults.mediaType.previews.length) {
    mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
  }
  mergedOptions.mediaType.previews = mergedOptions.mediaType.previews.map((preview) => preview.replace(/-preview/, ""));
  return mergedOptions;
}
function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}
var urlVariableRegex = /\{[^}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}
function omit(object, keysToOmit) {
  return Object.keys(object).filter((option) => !keysToOmit.includes(option)).reduce((obj, key) => {
    obj[key] = object[key];
    return obj;
  }, {});
}
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
  var value = context[key], result = [];
  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ""));
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_, expression, literal) {
    if (expression) {
      let operator = "";
      const values = [];
      if (operators.indexOf(expression.charAt(0)) !== -1) {
        operator = expression.charAt(0);
        expression = expression.substr(1);
      }
      expression.split(/,/g).forEach(function(variable) {
        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
        values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
      });
      if (operator && operator !== "+") {
        var separator = ",";
        if (operator === "?") {
          separator = "&";
        } else if (operator !== "#") {
          separator = operator;
        }
        return (values.length !== 0 ? operator : "") + values.join(separator);
      } else {
        return values.join(",");
      }
    } else {
      return encodeReserved(literal);
    }
  });
}
function parse(options) {
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map((preview) => preview.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
    }
    if (options.mediaType.previews.length) {
      const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
      headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
        const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
        return `application/vnd.github.${preview}-preview${format}`;
      }).join(",");
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      } else {
        headers["content-length"] = 0;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign({ method, url, headers }, typeof body !== "undefined" ? { body } : null, options.request ? { request: options.request } : null);
}
function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge.bind(null, DEFAULTS2),
    parse
  });
}
var VERSION = "6.0.12";
var userAgent = `octokit-endpoint.js/${VERSION} ${getUserAgent()}`;
var DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: "",
    previews: []
  }
};
var endpoint = withDefaults(null, DEFAULTS);

// node_modules/@octokit/request/dist-web/index.js
var import_node_fetch = __toESM(require_browser());

// node_modules/deprecation/dist-web/index.js
var Deprecation = class extends Error {
  constructor(message) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "Deprecation";
  }
};

// node_modules/@octokit/request-error/dist-web/index.js
var import_once = __toESM(require_once());
var logOnceCode = (0, import_once.default)((deprecation) => console.warn(deprecation));
var logOnceHeaders = (0, import_once.default)((deprecation) => console.warn(deprecation));
var RequestError = class extends Error {
  constructor(message, statusCode, options) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "HttpError";
    this.status = statusCode;
    let headers;
    if ("headers" in options && typeof options.headers !== "undefined") {
      headers = options.headers;
    }
    if ("response" in options) {
      this.response = options.response;
      headers = options.response.headers;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(/ .*$/, " [REDACTED]")
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
    Object.defineProperty(this, "code", {
      get() {
        logOnceCode(new Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
        return statusCode;
      }
    });
    Object.defineProperty(this, "headers", {
      get() {
        logOnceHeaders(new Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."));
        return headers || {};
      }
    });
  }
};

// node_modules/@octokit/request/dist-web/index.js
var VERSION2 = "5.6.3";
function getBufferResponse(response) {
  return response.arrayBuffer();
}
function fetchWrapper(requestOptions) {
  const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
  if (isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {
    requestOptions.body = JSON.stringify(requestOptions.body);
  }
  let headers = {};
  let status;
  let url;
  const fetch = requestOptions.request && requestOptions.request.fetch || import_node_fetch.default;
  return fetch(requestOptions.url, Object.assign({
    method: requestOptions.method,
    body: requestOptions.body,
    headers: requestOptions.headers,
    redirect: requestOptions.redirect
  }, requestOptions.request)).then((response) => __async(this, null, function* () {
    url = response.url;
    status = response.status;
    for (const keyAndValue of response.headers) {
      headers[keyAndValue[0]] = keyAndValue[1];
    }
    if ("deprecation" in headers) {
      const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
      const deprecationLink = matches && matches.pop();
      log.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
    }
    if (status === 204 || status === 205) {
      return;
    }
    if (requestOptions.method === "HEAD") {
      if (status < 400) {
        return;
      }
      throw new RequestError(response.statusText, status, {
        response: {
          url,
          status,
          headers,
          data: void 0
        },
        request: requestOptions
      });
    }
    if (status === 304) {
      throw new RequestError("Not modified", status, {
        response: {
          url,
          status,
          headers,
          data: yield getResponseData(response)
        },
        request: requestOptions
      });
    }
    if (status >= 400) {
      const data = yield getResponseData(response);
      const error = new RequestError(toErrorMessage(data), status, {
        response: {
          url,
          status,
          headers,
          data
        },
        request: requestOptions
      });
      throw error;
    }
    return getResponseData(response);
  })).then((data) => {
    return {
      status,
      url,
      headers,
      data
    };
  }).catch((error) => {
    if (error instanceof RequestError)
      throw error;
    throw new RequestError(error.message, 500, {
      request: requestOptions
    });
  });
}
function getResponseData(response) {
  return __async(this, null, function* () {
    const contentType = response.headers.get("content-type");
    if (/application\/json/.test(contentType)) {
      return response.json();
    }
    if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
      return response.text();
    }
    return getBufferResponse(response);
  });
}
function toErrorMessage(data) {
  if (typeof data === "string")
    return data;
  if ("message" in data) {
    if (Array.isArray(data.errors)) {
      return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}`;
    }
    return data.message;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters) {
    const endpointOptions = endpoint2.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request2 = (route2, parameters2) => {
      return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters2)));
    };
    Object.assign(request2, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2)
    });
    return endpointOptions.request.hook(request2, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults2.bind(null, endpoint2)
  });
}
var request = withDefaults2(endpoint, {
  headers: {
    "user-agent": `octokit-request.js/${VERSION2} ${getUserAgent()}`
  }
});

// node_modules/@octokit/graphql/dist-web/index.js
var VERSION3 = "4.8.0";
function _buildMessageForResponseErrors(data) {
  return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n");
}
var GraphqlResponseError = class extends Error {
  constructor(request2, headers, response) {
    super(_buildMessageForResponseErrors(response));
    this.request = request2;
    this.headers = headers;
    this.response = response;
    this.name = "GraphqlResponseError";
    this.errors = response.errors;
    this.data = response.data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var NON_VARIABLE_OPTIONS = [
  "method",
  "baseUrl",
  "url",
  "headers",
  "request",
  "query",
  "mediaType"
];
var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request2, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
    }
    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
        continue;
      return Promise.reject(new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
    }
  }
  const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
  const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }
  return request2(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(requestOptions, headers, response.data);
    }
    return response.data.data;
  });
}
function withDefaults3(request$1, newDefaults) {
  const newRequest = request$1.defaults(newDefaults);
  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };
  return Object.assign(newApi, {
    defaults: withDefaults3.bind(null, newRequest),
    endpoint: request.endpoint
  });
}
var graphql$1 = withDefaults3(request, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION3} ${getUserAgent()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults3(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}

// node_modules/@octokit/auth-token/dist-web/index.js
var REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
var REGEX_IS_INSTALLATION = /^ghs_/;
var REGEX_IS_USER_TO_SERVER = /^ghu_/;
function auth(token) {
  return __async(this, null, function* () {
    const isApp = token.split(/\./).length === 3;
    const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
    const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
    const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
    return {
      type: "token",
      token,
      tokenType
    };
  });
}
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}
function hook(token, request2, route, parameters) {
  return __async(this, null, function* () {
    const endpoint2 = request2.endpoint.merge(route, parameters);
    endpoint2.headers.authorization = withAuthorizationPrefix(token);
    return request2(endpoint2);
  });
}
var createTokenAuth = function createTokenAuth2(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }
  if (typeof token !== "string") {
    throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
  }
  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
};

// node_modules/@octokit/core/dist-web/index.js
var VERSION4 = "3.6.0";
var Octokit = class {
  constructor(options = {}) {
    const hook2 = new import_before_after_hook.Collection();
    const requestDefaults = {
      baseUrl: request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        hook: hook2.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    };
    requestDefaults.headers["user-agent"] = [
      options.userAgent,
      `octokit-core.js/${VERSION4} ${getUserAgent()}`
    ].filter(Boolean).join(" ");
    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }
    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }
    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }
    this.request = request.defaults(requestDefaults);
    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
    this.log = Object.assign({
      debug: () => {
      },
      info: () => {
      },
      warn: console.warn.bind(console),
      error: console.error.bind(console)
    }, options.log);
    this.hook = hook2;
    if (!options.authStrategy) {
      if (!options.auth) {
        this.auth = () => __async(this, null, function* () {
          return {
            type: "unauthenticated"
          };
        });
      } else {
        const auth2 = createTokenAuth(options.auth);
        hook2.wrap("request", auth2.hook);
        this.auth = auth2;
      }
    } else {
      const _a = options, { authStrategy } = _a, otherOptions = __objRest(_a, ["authStrategy"]);
      const auth2 = authStrategy(Object.assign({
        request: this.request,
        log: this.log,
        octokit: this,
        octokitOptions: otherOptions
      }, options.auth));
      hook2.wrap("request", auth2.hook);
      this.auth = auth2;
    }
    const classConstructor = this.constructor;
    classConstructor.plugins.forEach((plugin) => {
      Object.assign(this, plugin(this, options));
    });
  }
  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};
        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }
        super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {
          userAgent: `${options.userAgent} ${defaults.userAgent}`
        } : null));
      }
    };
    return OctokitWithDefaults;
  }
  static plugin(...newPlugins) {
    var _a;
    const currentPlugins = this.plugins;
    const NewOctokit = (_a = class extends this {
    }, _a.plugins = currentPlugins.concat(newPlugins.filter((plugin) => !currentPlugins.includes(plugin))), _a);
    return NewOctokit;
  }
};
Octokit.VERSION = VERSION4;
Octokit.plugins = [];

// mkdocsPublisher/githubInteraction/filesManagement.ts
var import_obsidian6 = require("obsidian");

// mkdocsPublisher/githubInteraction/upload.ts
var import_obsidian5 = require("obsidian");

// node_modules/js-base64/base64.mjs
var version = "3.7.2";
var VERSION5 = version;
var _hasatob = typeof atob === "function";
var _hasbtoa = typeof btoa === "function";
var _hasBuffer = typeof Buffer === "function";
var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var b64chs = Array.prototype.slice.call(b64ch);
var b64tab = ((a) => {
  let tab = {};
  a.forEach((c, i) => tab[c] = i);
  return tab;
})(b64chs);
var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
var _fromCC = String.fromCharCode.bind(String);
var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it, fn = (x) => x) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
var _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
var _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, "");
var btoaPolyfill = (bin) => {
  let u32, c0, c1, c2, asc = "";
  const pad = bin.length % 3;
  for (let i = 0; i < bin.length; ) {
    if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
      throw new TypeError("invalid character found");
    u32 = c0 << 16 | c1 << 8 | c2;
    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
  }
  return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
var _btoa = _hasbtoa ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
var _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
  const maxargs = 4096;
  let strs = [];
  for (let i = 0, l = u8a.length; i < l; i += maxargs) {
    strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
  }
  return _btoa(strs.join(""));
};
var fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
var cb_utob = (c) => {
  if (c.length < 2) {
    var cc = c.charCodeAt(0);
    return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  } else {
    var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
    return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  }
};
var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
var utob = (u) => u.replace(re_utob, cb_utob);
var _encode = _hasBuffer ? (s) => Buffer.from(s, "utf8").toString("base64") : _TE ? (s) => _fromUint8Array(_TE.encode(s)) : (s) => _btoa(utob(s));
var encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
var encodeURI2 = (src) => encode(src, true);
var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
var cb_btou = (cccc) => {
  switch (cccc.length) {
    case 4:
      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
      return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
    case 3:
      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
    default:
      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
  }
};
var btou = (b) => b.replace(re_btou, cb_btou);
var atobPolyfill = (asc) => {
  asc = asc.replace(/\s+/g, "");
  if (!b64re.test(asc))
    throw new TypeError("malformed base64.");
  asc += "==".slice(2 - (asc.length & 3));
  let u24, bin = "", r1, r2;
  for (let i = 0; i < asc.length; ) {
    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
  }
  return bin;
};
var _atob = _hasatob ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
var _toUint8Array = _hasBuffer ? (a) => _U8Afrom(Buffer.from(a, "base64")) : (a) => _U8Afrom(_atob(a), (c) => c.charCodeAt(0));
var toUint8Array = (a) => _toUint8Array(_unURI(a));
var _decode = _hasBuffer ? (a) => Buffer.from(a, "base64").toString("utf8") : _TD ? (a) => _TD.decode(_toUint8Array(a)) : (a) => btou(_atob(a));
var _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
var decode = (src) => _decode(_unURI(src));
var isValid = (src) => {
  if (typeof src !== "string")
    return false;
  const s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
var _noEnum = (v) => {
  return {
    value: v,
    enumerable: false,
    writable: true,
    configurable: true
  };
};
var extendString = function() {
  const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
  _add("fromBase64", function() {
    return decode(this);
  });
  _add("toBase64", function(urlsafe) {
    return encode(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return encode(this, true);
  });
  _add("toBase64URL", function() {
    return encode(this, true);
  });
  _add("toUint8Array", function() {
    return toUint8Array(this);
  });
};
var extendUint8Array = function() {
  const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
  _add("toBase64", function(urlsafe) {
    return fromUint8Array(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return fromUint8Array(this, true);
  });
  _add("toBase64URL", function() {
    return fromUint8Array(this, true);
  });
};
var extendBuiltins = () => {
  extendString();
  extendUint8Array();
};
var gBase64 = {
  version,
  VERSION: VERSION5,
  atob: _atob,
  atobPolyfill,
  btoa: _btoa,
  btoaPolyfill,
  fromBase64: decode,
  toBase64: encode,
  encode,
  encodeURI: encodeURI2,
  encodeURL: encodeURI2,
  utob,
  btou,
  decode,
  isValid,
  fromUint8Array,
  toUint8Array,
  extendString,
  extendUint8Array,
  extendBuiltins
};

// mkdocsPublisher/githubInteraction/delete.ts
var import_obsidian4 = require("obsidian");
function deleteFromGithub(silent = false, settings, octokit, branchName = "main", filesManagement) {
  return __async(this, null, function* () {
    const getAllFile = yield filesManagement.getAllFileFromRepo(branchName, octokit, settings);
    const filesInRepo = yield filterGithubFile(getAllFile, settings);
    if (!filesInRepo) {
      let errorMsg = "";
      if (settings.folderDefaultName.length > 0) {
        if (settings.folderDefaultName.length > 0) {
          errorMsg = "You need to configure a default folder name in the settings to use this command.";
        } else if (settings.downloadedFolder === "yaml" /* yaml */ && settings.rootFolder.length === 0) {
          errorMsg = "You need to configure a root folder in the settings to use this command.";
        }
        if (!silent) {
          new import_obsidian4.Notice("Error : " + errorMsg);
        }
      }
      return false;
    }
    const allSharedFiles = filesManagement.getAllFileWithPath();
    const allSharedConverted = allSharedFiles.map((file) => {
      return file.converted;
    });
    let deletedSuccess = 0;
    let deletedFailed = 0;
    for (const file of filesInRepo) {
      if (!allSharedConverted.includes(file.file.trim())) {
        const checkingIndex = file.file.contains("index") ? yield checkIndexFiles(octokit, settings, file.file) : false;
        try {
          if (!checkingIndex) {
            console.log("trying to delete file : " + file.file);
            const reponse = yield octokit.request("DELETE /repos/{owner}/{repo}/contents/{path}", {
              owner: settings.githubName,
              repo: settings.githubRepo,
              path: file.file,
              message: "Delete file",
              sha: file.sha,
              branch: branchName
            });
            if (reponse.status === 200) {
              deletedSuccess++;
            } else {
              deletedFailed++;
            }
          }
        } catch (e) {
          console.error(e);
        }
      }
    }
    let successMsg = "No files have been deleted";
    let failedMsg = "";
    if (deletedSuccess > 0) {
      successMsg = `Successfully deleted ${deletedSuccess} files`;
    }
    if (deletedFailed > 0) {
      failedMsg = `Failed to delete ${deletedFailed} files.`;
    }
    if (!silent) {
      new import_obsidian4.Notice(successMsg + failedMsg);
    }
    return true;
  });
}
function excludedFileFromDelete(file, settings) {
  const autoCleanExcluded = settings.autoCleanUpExcluded.split(",");
  if (autoCleanExcluded.length > 0) {
    for (const excludedFile of autoCleanExcluded) {
      if (file.trim().includes(excludedFile.trim()) && excludedFile.length > 0) {
        return true;
      }
    }
  }
  return false;
}
function filterGithubFile(fileInRepo, settings) {
  return __async(this, null, function* () {
    const sharedFilesInRepo = [];
    for (const file of fileInRepo) {
      if (settings.downloadedFolder === "yaml" /* yaml */ && settings.rootFolder.length === 0 || settings.folderDefaultName.length === 0) {
        return false;
      }
      if ((file.file.includes(settings.folderDefaultName) || settings.downloadedFolder === "yaml" /* yaml */ && file.file.includes(settings.rootFolder) || settings.defaultImageFolder.length > 0 && file.file.includes(settings.defaultImageFolder)) && !excludedFileFromDelete(file.file, settings) && file.file.match(/(md|jpe?g|png|gif|bmp|svg|mp3|webm|wav|m4a|ogg|3gp|flac|mp4|ogv|pdf)$/)) {
        sharedFilesInRepo.push(file);
      }
    }
    return sharedFilesInRepo;
  });
}
function parseYamlFrontmatter(contents) {
  const yamlFrontmatter = contents.split("---")[1];
  const yamlFrontmatterParsed = yamlFrontmatter.split("\n");
  let yamlFrontmatterParsedCleaned = {};
  for (const line of yamlFrontmatterParsed) {
    if (typeof line !== "undefined" && line.length > 1) {
      const yamlFrontmatter2 = line.split(":");
      yamlFrontmatterParsedCleaned[yamlFrontmatter2[0]] = yamlFrontmatter2[1];
    }
  }
  yamlFrontmatterParsedCleaned = trimObject(yamlFrontmatterParsedCleaned);
  return yamlFrontmatterParsedCleaned;
}
function checkIndexFiles(octokit, settings, path) {
  return __async(this, null, function* () {
    try {
      const fileRequest = yield octokit.request("GET /repos/{owner}/{repo}/contents/{path}", {
        owner: settings.githubName,
        repo: settings.githubRepo,
        path
      });
      if (fileRequest.status === 200) {
        const fileContent = gBase64.decode(fileRequest.data.content);
        const fileFrontmatter = parseYamlFrontmatter(fileContent);
        return fileFrontmatter.index === "true" || fileFrontmatter.autoclean === "false" || !fileFrontmatter.share;
      }
    } catch (e) {
      console.log(e);
      return false;
    }
  });
}

// mkdocsPublisher/utils/convertText.ts
function convertWikilinks(fileContent, settings, linkedFiles) {
  if (!settings.convertWikiLinks) {
    return fileContent;
  }
  const wikiRegex = /\[\[.*?\]\]/g;
  const wikiMatches = fileContent.match(wikiRegex);
  if (wikiMatches) {
    const fileRegex = /(\[\[).*?([\]|])/;
    for (const wikiMatch of wikiMatches) {
      const fileMatch = wikiMatch.match(fileRegex);
      if (fileMatch) {
        const fileName = fileMatch[0].replace("[[", "").replace("|", "");
        const linkedFile = linkedFiles.find((item) => item.linkFrom === fileName);
        if (linkedFile) {
          const altText = linkedFile.altText.length > 0 ? linkedFile.altText : linkedFile.linked.extension === "md" ? linkedFile.linked.basename : "";
          const linkCreator = `[${altText}](${encodeURI(linkedFile.linkFrom)})`;
          fileContent = fileContent.replace(wikiMatch, linkCreator);
        } else if (!fileName.startsWith("http")) {
          const altMatch = wikiMatch.match(/(\|).*(]])/);
          const altCreator = fileName.split("/");
          const altLink = creatorAltLink(altMatch, altCreator, fileName.split(".").at(-1));
          const linkCreator = `[${altLink}](${encodeURI(fileName.trim())})`;
          fileContent = fileContent.replace(wikiMatch, linkCreator);
        }
      }
    }
  }
  return fileContent;
}
function convertLinkCitation(fileContent, settings, linkedFiles, metadataCache, sourceFile) {
  if (!settings.convertForGithub) {
    return fileContent;
  }
  for (const linkedFile of linkedFiles) {
    const pathInGithub = createRelativePath(sourceFile, linkedFile, metadataCache, settings).replace(".md", "");
    const regexToReplace = new RegExp(`(\\[{2}${linkedFile.linkFrom}(\\|.*)?\\]{2})|(\\[.*\\]\\(${linkedFile.linkFrom}\\))`, "g");
    const matchedLink = fileContent.match(regexToReplace);
    if (matchedLink) {
      for (const link of matchedLink) {
        const regToReplace = new RegExp(`${linkedFile.linkFrom}`);
        const newLink = link.replace(regToReplace, pathInGithub);
        fileContent = fileContent.replace(link, newLink);
      }
    }
  }
  return fileContent;
}
function creatorAltLink(altMatch, altCreator, fileExtension) {
  if (altMatch) {
    return altMatch[0].replace("]]", "").replace("|", "");
  }
  if (fileExtension === "md") {
    return altCreator.length > 1 ? altCreator[altCreator.length - 1] : altCreator[0];
  }
  return "";
}

// mkdocsPublisher/utils/status_bar.ts
var ShareStatusBar = class {
  constructor(statusBarItem, numberOfNotesToPublish) {
    this.statusBarItem = statusBarItem;
    this.counter = 0;
    this.numberOfNotesToPublish = numberOfNotesToPublish;
    this.statusBarItem.createEl("span", { text: "" });
    this.status = this.statusBarItem.createEl("span", { text: `${this.numberOfNotesToPublish} files marked for sharing` });
  }
  increment() {
    this.status.setText(`\u231BSharing files: ${++this.counter}/${this.numberOfNotesToPublish}`);
  }
  finish(displayDurationMillisec) {
    this.status.setText(`\u2705 Published files: ${this.counter}/${this.numberOfNotesToPublish}`);
    setTimeout(() => {
      this.statusBarItem.remove();
    }, displayDurationMillisec);
  }
  error() {
    this.statusBarItem.remove();
  }
};

// mkdocsPublisher/githubInteraction/upload.ts
var MkdocsPublish = class {
  constructor(vault, metadataCache, settings, octokit, plugin) {
    this.vault = vault;
    this.metadataCache = metadataCache;
    this.settings = settings;
    this.octokit = octokit;
    this.plugin = plugin;
  }
  statusBarForEmbed(linkedFiles, fileHistory, ref = "main", deepScan) {
    return __async(this, null, function* () {
      if (linkedFiles.length > 0) {
        if (linkedFiles.length > 1) {
          const statusBarItems = this.plugin.addStatusBarItem();
          const statusBar = new ShareStatusBar(statusBarItems, linkedFiles.length);
          for (const image of linkedFiles) {
            if (image.extension === "md" && !fileHistory.includes(image) && deepScan) {
              fileHistory.push(image);
              yield this.publish(image, false, ref, fileHistory, true);
            } else {
              yield this.uploadImage(image, ref);
            }
            statusBar.increment();
          }
          statusBar.finish(8e3);
        } else {
          const embed = linkedFiles[0];
          if (embed.extension === "md" && !fileHistory.includes(embed) && deepScan) {
            fileHistory.push(embed);
            yield this.publish(embed, false, ref, fileHistory, true);
          } else {
            yield this.uploadImage(embed, ref);
          }
        }
      }
      return fileHistory;
    });
  }
  publish(_0) {
    return __async(this, arguments, function* (file, autoclean = false, ref = "main", fileHistory = [], deepScan = false) {
      const shareFiles = new FilesManagement(this.vault, this.metadataCache, this.settings, this.octokit, this.plugin);
      const sharedKey = this.settings.shareKey;
      const frontmatter = this.metadataCache.getFileCache(file).frontmatter;
      if (!frontmatter || !frontmatter[sharedKey] || shareFiles.checkExcludedFolder(file) || file.extension !== "md" || fileHistory.includes(file)) {
        return false;
      }
      try {
        let text = yield this.vault.cachedRead(file);
        fileHistory.push(file);
        const embedFiles = shareFiles.getEmbed(file);
        const linkedFiles = shareFiles.getLinkedImageAndFiles(file);
        text = convertLinkCitation(text, this.settings, linkedFiles, this.metadataCache, file);
        text = convertWikilinks(text, this.settings, linkedFiles);
        const path = getReceiptFolder(file, this.settings, this.metadataCache);
        yield this.uploadText(file.path, text, path, file.name, ref);
        yield this.statusBarForEmbed(embedFiles, fileHistory, ref, deepScan);
        if (autoclean) {
          yield deleteFromGithub(true, this.settings, this.octokit, ref, shareFiles);
        }
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    });
  }
  upload(filePath, content, path, title = "", ref = "main") {
    return __async(this, null, function* () {
      if (!this.settings.githubRepo) {
        new import_obsidian5.Notice("Config error : You need to define a github repo in the plugin settings");
        throw {};
      }
      if (!this.settings.githubName) {
        new import_obsidian5.Notice("Config error : You need to define your github username in the plugin settings");
        throw {};
      }
      const octokit = this.octokit;
      const payload = {
        owner: this.settings.githubName,
        repo: this.settings.githubRepo,
        path,
        message: `Adding ${title}`,
        content,
        sha: "",
        branch: ref
      };
      try {
        const response = yield octokit.request("GET /repos/{owner}/{repo}/contents/{path}", {
          owner: this.settings.githubName,
          repo: this.settings.githubRepo,
          path,
          ref
        });
        if (response.status === 200 && response.data.type === "file") {
          payload.sha = response.data.sha;
        }
      } catch (e) {
        console.log("The 404 error is normal ! It means that the file does not exist yet. Don't worry \u2764\uFE0F.");
      }
      payload.message = `Update note ${title}`;
      yield octokit.request("PUT /repos/{owner}/{repo}/contents/{path}", payload);
    });
  }
  uploadImage(imageFile, ref = "main") {
    return __async(this, null, function* () {
      const imageBin = yield this.vault.readBinary(imageFile);
      const image64 = (0, import_obsidian5.arrayBufferToBase64)(imageBin);
      const path = getImageLinkOptions(imageFile, this.settings);
      yield this.upload(imageFile.path, image64, path, "", ref);
    });
  }
  uploadText(filePath, text, path, title = "", ref = "main") {
    return __async(this, null, function* () {
      try {
        const contentBase64 = gBase64.encode(text).toString();
        yield this.upload(filePath, contentBase64, path, title, ref);
      } catch (e) {
        console.error(e);
      }
    });
  }
  workflowGestion() {
    return __async(this, null, function* () {
      let finished = false;
      if (this.settings.workflowName.length === 0) {
        return false;
      } else {
        const octokit = this.octokit;
        yield octokit.request("POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches", {
          owner: this.settings.githubName,
          repo: this.settings.githubRepo,
          workflow_id: this.settings.workflowName,
          ref: "main"
        });
        while (!finished) {
          yield sleep(1e4);
          const workflowGet = yield octokit.request("GET /repos/{owner}/{repo}/actions/runs", {
            owner: this.settings.githubName,
            repo: this.settings.githubRepo
          });
          if (workflowGet.data.workflow_runs.length > 0) {
            const build = workflowGet.data.workflow_runs.find((run) => run.name === this.settings.workflowName.replace(".yml", ""));
            if (build.status === "completed") {
              finished = true;
              return true;
            }
          }
        }
      }
    });
  }
};

// mkdocsPublisher/githubInteraction/filesManagement.ts
var FilesManagement = class extends MkdocsPublish {
  constructor(vault, metadataCache, settings, octokit, plugin) {
    super(vault, metadataCache, settings, octokit, plugin);
    this.vault = vault;
    this.metadataCache = metadataCache;
    this.settings = settings;
    this.octokit = octokit;
    this.plugin = plugin;
  }
  getSharedFiles() {
    const files = this.vault.getMarkdownFiles();
    const shared_File = [];
    const sharedkey = this.settings.shareKey;
    for (const file of files) {
      try {
        const frontMatter = this.metadataCache.getCache(file.path).frontmatter;
        if (frontMatter && frontMatter[sharedkey] === true) {
          shared_File.push(file);
        }
      } catch (e) {
      }
    }
    return shared_File;
  }
  getAllFileWithPath() {
    const files = this.vault.getFiles();
    const allFileWithPath = [];
    const shareKey = this.settings.shareKey;
    for (const file of files) {
      const fileExtension = file.extension;
      if (fileExtension.match(/(png|jpe?g|svg|bmp|gif)$/i)) {
        const filepath = getImageLinkOptions(file, this.settings);
        allFileWithPath.push({
          "converted": filepath,
          "real": file.path
        });
      } else if (file.extension == "md") {
        const frontMatter = this.metadataCache.getCache(file.path).frontmatter;
        if (frontMatter && frontMatter[shareKey] === true && file.extension === "md") {
          const filepath = getReceiptFolder(file, this.settings, this.metadataCache);
          allFileWithPath.push({
            "converted": filepath,
            "real": file.path
          });
        }
      }
    }
    return allFileWithPath;
  }
  getLinkedImageAndFiles(file) {
    const linkedFiles = this.getEmbedFiles(file);
    const imageEmbedded = this.metadataCache.getFileCache(file).embeds;
    if (imageEmbedded != void 0) {
      for (const image of imageEmbedded) {
        try {
          const imageLink = this.metadataCache.getFirstLinkpathDest(image.link, file.path);
          const imageExt = imageLink.extension;
          if (imageExt.match(/(png|jpe?g|svg|bmp|gif|md)$/i)) {
            linkedFiles.push({
              "linked": imageLink,
              "linkFrom": image.link,
              "altText": image.displayText
            });
          }
        } catch (e) {
        }
      }
    }
    return linkedFiles;
  }
  getEmbedFiles(file) {
    const embedCaches = this.metadataCache.getCache(file.path).links;
    const embedList = [];
    if (embedCaches != void 0) {
      for (const embedCache of embedCaches) {
        try {
          const linkedFile = this.metadataCache.getFirstLinkpathDest(embedCache.link, file.path);
          if (linkedFile) {
            if (linkedFile.extension === "md") {
              embedList.push({
                "linked": linkedFile,
                "linkFrom": embedCache.link,
                "altText": embedCache.displayText
              });
            }
          }
        } catch (e) {
          console.log(e);
          console.log("Error with this links : " + embedCache.link);
        }
      }
      return embedList;
    }
    return [];
  }
  getEmbed(file) {
    const embedCaches = this.metadataCache.getCache(file.path).embeds;
    const imageList = [];
    if (embedCaches != void 0) {
      for (const embed of embedCaches) {
        try {
          const imageLink = this.metadataCache.getFirstLinkpathDest(embed.link, file.path);
          if (imageLink.name.match(/(png|jpe?g|svg|bmp|gif)$/i) && this.settings.embedImage) {
            imageList.push(imageLink);
          } else if (imageLink.extension === "md") {
            const sharedKey = this.settings.shareKey;
            const frontmatter = this.metadataCache.getFileCache(imageLink).frontmatter;
            if (frontmatter && frontmatter[sharedKey] && !this.checkExcludedFolder(imageLink) && this.settings.embedNotes) {
              imageList.push(imageLink);
            }
          }
        } catch (e) {
          console.log(e);
          console.log("Error with this file : " + embed.displayText);
        }
      }
      return imageList;
    }
    return [];
  }
  checkExcludedFolder(file) {
    const excludedFolder = this.settings.ExcludedFolder.split(",").filter((x) => x != "");
    if (excludedFolder.length > 0) {
      for (let i = 0; i < excludedFolder.length; i++) {
        if (file.path.contains(excludedFolder[i].trim())) {
          return true;
        }
      }
    }
    return false;
  }
  getLastEditedTimeRepo(octokit, githubRepo, settings) {
    return __async(this, null, function* () {
      const commits = yield octokit.request("GET /repos/{owner}/{repo}/commits", {
        owner: settings.githubName,
        repo: settings.githubRepo,
        path: githubRepo.file
      });
      const lastCommittedFile = commits.data[0];
      return new Date(lastCommittedFile.commit.committer.date);
    });
  }
  getAllFileFromRepo(ref = "main", octokit, settings) {
    return __async(this, null, function* () {
      const filesInRepo = [];
      try {
        const repoContents = yield octokit.request("GET /repos/{owner}/{repo}/git/trees/{tree_sha}", {
          owner: settings.githubName,
          repo: settings.githubRepo,
          tree_sha: ref,
          recursive: "true"
        });
        if (repoContents.status === 200) {
          const files = repoContents.data.tree;
          for (const file of files) {
            const basename = (name) => /([^/\\.]*)(\..*)?$/.exec(name)[1];
            if (file.type === "blob" && basename(file.path).length > 0 && basename(file.path) != "vault_published") {
              filesInRepo.push({
                file: file.path,
                sha: file.sha
              });
            }
          }
        }
      } catch (e) {
        console.log(e);
      }
      return filesInRepo;
    });
  }
  getNewFiles(allFileWithPath, githubSharedFiles, vault) {
    const newFiles = [];
    for (const file of allFileWithPath) {
      if (!githubSharedFiles.some((x) => x.file === file.converted.trim())) {
        const fileInVault = vault.getAbstractFileByPath(file.real.trim());
        if (fileInVault && fileInVault instanceof import_obsidian6.TFile && fileInVault.extension === "md") {
          newFiles.push(fileInVault);
        }
      }
    }
    return newFiles;
  }
  getEditedFiles(allFileWithPath, githubSharedFiles, vault, newFiles) {
    return __async(this, null, function* () {
      for (const file of allFileWithPath) {
        if (githubSharedFiles.some((x) => x.file === file.converted.trim())) {
          const githubSharedFile = githubSharedFiles.find((x) => x.file === file.converted.trim());
          const repoEditedTime = yield this.getLastEditedTimeRepo(this.octokit, githubSharedFile, this.settings);
          const fileInVault = vault.getAbstractFileByPath(file.real.trim());
          if (fileInVault && fileInVault instanceof import_obsidian6.TFile && fileInVault.extension === "md") {
            const vaultEditedTime = new Date(fileInVault.stat.mtime);
            if (vaultEditedTime > repoEditedTime) {
              console.log("edited file ", fileInVault.path, " / ", vaultEditedTime, " vs ", repoEditedTime);
              newFiles.push(fileInVault);
            }
          }
        }
      }
      return newFiles;
    });
  }
};

// mkdocsPublisher/githubInteraction/branch.ts
var GithubBranch = class extends FilesManagement {
  constructor(settings, octokit, vault, metadataCache, plugin) {
    super(vault, metadataCache, settings, octokit, plugin);
    this.settings = settings;
    this.octokit = octokit;
    this.plugin = plugin;
  }
  getMasterBranch() {
    return __async(this, null, function* () {
      const allBranch = yield this.octokit.request("GET /repos/{owner}/{repo}/branches", {
        owner: this.settings.githubName,
        repo: this.settings.githubRepo
      });
      const mainBranch = allBranch.data.find((branch) => branch.name === "main" || branch.name === "master");
      return mainBranch.name;
    });
  }
  newBranch(branchName) {
    return __async(this, null, function* () {
      const allBranch = yield this.octokit.request("GET /repos/{owner}/{repo}/branches", {
        owner: this.settings.githubName,
        repo: this.settings.githubRepo
      });
      const mainBranch = allBranch.data.find((branch) => branch.name === "main" || branch.name === "master");
      const shaMainBranch = mainBranch.commit.sha;
      try {
        const branch = yield this.octokit.request("POST /repos/{owner}/{repo}/git/refs", {
          owner: this.settings.githubName,
          repo: this.settings.githubRepo,
          ref: "refs/heads/" + branchName,
          sha: shaMainBranch
        });
        return branch.status === 201;
      } catch (e) {
        const allBranch2 = yield this.octokit.request("GET /repos/{owner}/{repo}/branches", {
          owner: this.settings.githubName,
          repo: this.settings.githubRepo
        });
        const mainBranch2 = allBranch2.data.find((branch) => branch.name === branchName);
        return !!mainBranch2;
      }
    });
  }
  pullRequest(branchName) {
    return __async(this, null, function* () {
      return yield this.octokit.request("POST /repos/{owner}/{repo}/pulls", {
        owner: this.settings.githubName,
        repo: this.settings.githubRepo,
        title: `PullRequest ${branchName} from Obsidian`,
        body: "",
        head: branchName,
        base: "main"
      });
    });
  }
  deleteBranch(branchName) {
    return __async(this, null, function* () {
      const octokit = new Octokit({
        auth: this.settings.GhToken
      });
      try {
        const branch = yield octokit.request("DELETE /repos/{owner}/{repo}/git/refs/heads/" + branchName, {
          owner: this.settings.githubName,
          repo: this.settings.githubRepo
        });
        return branch.status === 200;
      } catch (e) {
        return false;
      }
    });
  }
  mergePullRequest(branchName, silent = false, pullRequestNumber) {
    return __async(this, null, function* () {
      const octokit = new Octokit({
        auth: this.settings.GhToken
      });
      const branch = yield octokit.request("PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge", {
        owner: this.settings.githubName,
        repo: this.settings.githubRepo,
        pull_number: pullRequestNumber,
        commit_title: `[PUBLISHER] Merge #${pullRequestNumber}`,
        merge_method: "squash"
      });
      return branch.status === 200;
    });
  }
  updateRepository(branchName) {
    return __async(this, null, function* () {
      const pullRequest = yield this.pullRequest(branchName);
      yield this.mergePullRequest(branchName, true, pullRequest.data.number);
      yield this.deleteBranch(branchName);
      return true;
    });
  }
};

// mkdocsPublisher/utils/commands.ts
var import_obsidian7 = require("obsidian");
function shareAllMarkedNotes(PublisherManager, settings, octokit, statusBarItems, branchName, sharedFiles, createGithubBranch = true) {
  return __async(this, null, function* () {
    try {
      const statusBar = new ShareStatusBar(statusBarItems, sharedFiles.length);
      let errorCount = 0;
      if (sharedFiles.length > 0) {
        const publishedFiles = sharedFiles.map((file) => file.name);
        if (createGithubBranch) {
          yield PublisherManager.newBranch(branchName);
        }
        for (let files = 0; files < sharedFiles.length; files++) {
          try {
            const file = sharedFiles[files];
            statusBar.increment();
            yield PublisherManager.publish(file, false, branchName);
          } catch (e) {
            errorCount++;
            new import_obsidian7.Notice(t("unablePublishNote")(sharedFiles[files].name));
          }
        }
        statusBar.finish(8e3);
        const noticeValue = `${publishedFiles.length - errorCount} notes`;
        yield deleteFromGithub(true, settings, octokit, branchName, PublisherManager);
        const update = yield PublisherManager.updateRepository(branchName);
        if (update) {
          yield noticeMessage(PublisherManager, noticeValue, settings);
        } else {
          new import_obsidian7.Notice(t("errorPublish")(settings.githubRepo));
        }
      }
    } catch (error) {
      console.error(error);
      new import_obsidian7.Notice(t("unablePublishMultiNotes"));
    }
  });
}
function deleteUnsharedDeletedNotes(PublisherManager, settings, octokit, branchName) {
  return __async(this, null, function* () {
    try {
      new import_obsidian7.Notice(t("startingClean")(settings.githubRepo));
      yield PublisherManager.newBranch(branchName);
      yield deleteFromGithub(false, settings, octokit, branchName, PublisherManager);
      yield PublisherManager.updateRepository(branchName);
    } catch (e) {
      console.error(e);
    }
  });
}
function shareOneNote(branchName, PublisherManager, settings, file, metadataCache) {
  return __async(this, null, function* () {
    try {
      yield PublisherManager.newBranch(branchName);
      const publishSuccess = yield PublisherManager.publish(file, true, branchName, [], true);
      if (publishSuccess) {
        const update = yield PublisherManager.updateRepository(branchName);
        if (update) {
          yield noticeMessage(PublisherManager, file, settings);
          yield createLink(file, settings, metadataCache);
        } else {
          new import_obsidian7.Notice(t("errorPublish")(settings.githubRepo));
        }
      }
    } catch (error) {
      console.error(error);
      new import_obsidian7.Notice(t("errorPublish")(settings.githubRepo));
    }
  });
}
function shareNewNote(PublisherManager, octokit, branchName, vault, plugin) {
  return __async(this, null, function* () {
    const settings = plugin.settings;
    new import_obsidian7.Notice(t("scanningRepo"));
    const branchMaster = yield PublisherManager.getMasterBranch();
    const sharedFilesWithPaths = PublisherManager.getAllFileWithPath();
    const githubSharedNotes = yield PublisherManager.getAllFileFromRepo(branchMaster, octokit, settings);
    const newlySharedNotes = PublisherManager.getNewFiles(sharedFilesWithPaths, githubSharedNotes, vault);
    if (newlySharedNotes.length > 0) {
      new import_obsidian7.Notice(t("foundNoteToSend")(`${newlySharedNotes.length}`));
      const statusBarElement = plugin.addStatusBarItem();
      yield PublisherManager.newBranch(branchName);
      yield shareAllMarkedNotes(PublisherManager, plugin.settings, octokit, statusBarElement, branchName, newlySharedNotes);
    } else {
      new import_obsidian7.Notice(t("noNewNote"));
    }
  });
}
function shareAllEditedNotes(PublisherManager, octokit, branchName, vault, plugin) {
  return __async(this, null, function* () {
    const settings = plugin.settings;
    new import_obsidian7.Notice(t("scanningRepo"));
    const branchMaster = yield PublisherManager.getMasterBranch();
    const sharedFilesWithPaths = PublisherManager.getAllFileWithPath();
    const githubSharedNotes = yield PublisherManager.getAllFileFromRepo(branchMaster, octokit, settings);
    const newSharedFiles = PublisherManager.getNewFiles(sharedFilesWithPaths, githubSharedNotes, vault);
    const newlySharedNotes = yield PublisherManager.getEditedFiles(sharedFilesWithPaths, githubSharedNotes, vault, newSharedFiles);
    if (newlySharedNotes.length > 0) {
      new import_obsidian7.Notice(t("foundNoteToSend")(`${newlySharedNotes.length}`));
      const statusBarElement = plugin.addStatusBarItem();
      yield PublisherManager.newBranch(branchName);
      yield shareAllMarkedNotes(PublisherManager, settings, octokit, statusBarElement, branchName, newlySharedNotes);
    } else {
      new import_obsidian7.Notice(t("noNewNote"));
    }
  });
}
function shareOnlyEdited(PublisherManager, octokit, branchName, vault, plugin) {
  return __async(this, null, function* () {
    const settings = plugin.settings;
    new import_obsidian7.Notice(t("scanningRepo"));
    const branchMaster = yield PublisherManager.getMasterBranch();
    const sharedFilesWithPaths = PublisherManager.getAllFileWithPath();
    const githubSharedNotes = yield PublisherManager.getAllFileFromRepo(branchMaster, octokit, settings);
    const newSharedFiles = [];
    const newlySharedNotes = yield PublisherManager.getEditedFiles(sharedFilesWithPaths, githubSharedNotes, vault, newSharedFiles);
    if (newlySharedNotes.length > 0) {
      new import_obsidian7.Notice(t("foundNoteToSend")(`${newlySharedNotes.length}`));
      const statusBarElement = plugin.addStatusBarItem();
      yield PublisherManager.newBranch(branchName);
      yield shareAllMarkedNotes(PublisherManager, settings, octokit, statusBarElement, branchName, newlySharedNotes);
    } else {
      new import_obsidian7.Notice(t("noNewNote"));
    }
  });
}

// mkdocsPublisher/main.ts
var MkdocsPublication = class extends import_obsidian8.Plugin {
  onload() {
    return __async(this, null, function* () {
      console.log("Github Publisher loaded");
      yield this.loadSettings();
      this.addSettingTab(new MkdocsSettingsTab(this.app, this));
      const octokit = new Octokit({ auth: this.settings.GhToken });
      const PublisherManager = new GithubBranch(this.settings, octokit, this.app.vault, this.app.metadataCache, this);
      const branchName = app.vault.getName() + "-" + new Date().toLocaleDateString("en-US").replace(/\//g, "-");
      this.registerEvent(this.app.workspace.on("file-menu", (menu, file) => {
        if (disablePublish(this.app, this.settings, file) && this.settings.fileMenu) {
          menu.addItem((item) => {
            item.setSection("action");
            item.setTitle(t("shareViewFiles")(file.basename)).setIcon("share").onClick(() => __async(this, null, function* () {
              yield shareOneNote(branchName, PublisherManager, this.settings, file, this.app.metadataCache);
            }));
          });
          menu.addSeparator();
        }
      }));
      this.registerEvent(this.app.workspace.on("editor-menu", (menu, editor, view) => {
        if (disablePublish(this.app, this.settings, view.file) && this.settings.editorMenu) {
          menu.addSeparator();
          menu.addItem((item) => {
            item.setSection("mkdocs-publisher");
            item.setTitle(t("shareViewFiles")(view.file.basename)).setIcon("share").onClick(() => __async(this, null, function* () {
              yield shareOneNote(branchName, PublisherManager, this.settings, view.file, this.app.metadataCache);
            }));
          });
        }
      }));
      this.addCommand({
        id: "publisher-one",
        name: t("shareActiveFile"),
        hotkeys: [],
        checkCallback: (checking) => {
          if (disablePublish(this.app, this.settings, this.app.workspace.getActiveFile())) {
            if (!checking) {
              shareOneNote(branchName, PublisherManager, this.settings, this.app.workspace.getActiveFile(), this.app.metadataCache);
            }
            return true;
          }
          return false;
        }
      });
      this.addCommand({
        id: "publisher-delete-clean",
        name: t("publisherDeleteClean"),
        hotkeys: [],
        checkCallback: (checking) => {
          if (this.settings.autoCleanUp) {
            if (!checking) {
              deleteUnsharedDeletedNotes(PublisherManager, this.settings, octokit, branchName);
            }
            return true;
          }
          return false;
        }
      });
      this.addCommand({
        id: "publisher-publish-all",
        name: t("uploadAllNotes"),
        callback: () => __async(this, null, function* () {
          const sharedFiles = PublisherManager.getSharedFiles();
          const statusBarItems = this.addStatusBarItem();
          yield shareAllMarkedNotes(PublisherManager, this.settings, octokit, statusBarItems, branchName, sharedFiles, true);
        })
      });
      this.addCommand({
        id: "publisher-upload-new",
        name: t("uploadNewNotes"),
        callback: () => __async(this, null, function* () {
          yield shareNewNote(PublisherManager, octokit, branchName, this.app.vault, this);
        })
      });
      this.addCommand({
        id: "publisher-upload-all-edited-new",
        name: t("uploadAllNewEditedNote"),
        callback: () => __async(this, null, function* () {
          yield shareAllEditedNotes(PublisherManager, octokit, branchName, this.app.vault, this);
        })
      });
      this.addCommand({
        id: "publisher-upload-edited",
        name: t("uploadAllEditedNote"),
        callback: () => __async(this, null, function* () {
          yield shareOnlyEdited(PublisherManager, octokit, branchName, this.app.vault, this);
        })
      });
    });
  }
  onunload() {
    console.log("Github Publisher unloaded");
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
